#include <omp.h>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>
#include <time.h>
#include <locale.h>
#include <windows.h>
using namespace std;

FILE *stream;                                               // Файловый поток.

/*************************************************************************/
/* Процедура printTimeStamp для определения и вывода текущего времени.   */
/* Принимаемые параметры: нет                                            */
/* Глобальные переменные:                                                */
/*   stream - файловый поток.                                            */
/* Возвращаемый результат: нет                                           */
/* Изменяемые переменные: нет                                            */
/*                                                                       */
/* Описание:                                                             */
/* Получить текущее время, вывести его на экран и записать в файл        */
/* определяемый потоком stream.                                          */
/* Формат выводимого времени: hh:mm:ss.fff                               */
/* где hh - часы, mm - минуты, ss - секунды, fff - миллисекунды.         */
/*************************************************************************/
void printTimeStamp()
{
             SYSTEMTIME timeStamp;                          // Текущее время.
             GetLocalTime (&timeStamp);              // Определить текущее время.
             printf("%02d:%02d:%02d.%03d",           // Вывести текущее время на экран.
                    timeStamp.wHour, timeStamp.wMinute,
                       timeStamp.wSecond, timeStamp.wMilliseconds);
             fprintf(stream, "%02d:%02d:%02d.%03d",  // Записать текущее время в файл.
                    timeStamp.wHour, timeStamp.wMinute,
                       timeStamp.wSecond, timeStamp.wMilliseconds);
}

/*************************************************************************/
/* Процедура writer, моделирующая действия писателей.                    */
/* Принимаемые параметры:                                                */
/*   storage - хранилище, в котором писатель сохраняет сообщение;        */
/*   totalWriters - количество писателей;                                */
/*   activeReaders - количество читателей, работающих с хранилищем       */
/*     в настоящий момент;                                               */
/*   writeLock - замок для взаимоблокировки писателей;                   */
/*   readLock - переменная для блокировки читателей.                     */
/* Глобальные переменные:                                                */
/*   stream - файловый поток.                                            */
/* Возвращаемый результат: нет                                           */
/* Изменяемые переменные: storage, writeLock, readLock.                  */
/*                                                                       */
/* Алгоритм работы:                                                      */
/* 1) Создать параллельные потоки в количестве totalWriters.             */
/* 2) Определить номер threads текущего потока-писателя.                 */
/* 3) Выполнять в бесконечном цикле:                                     */
/*    3.1) Выждать случайное время (в диапазоне от 3 до 18 секунд).      */
/*    3.2) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс обратился к хранилищу.                    */
/*    3.3) Запретить доступ к хранилищу другим писателям. При этом если  */
/*         другой писатель уже запросил доступ к хранилищу, то:          */
/*           - вывести на экран и записать в файл                        */
/*             информационное сообщение об этом;                         */
/*           - заблокировать текущий поток (выполняется с помощью        */
/*             попытки повторно установить замок writeLock).             */
/*    3.4) Запретить доступ к хранилищу новым читателям.                 */
/*    3.5) Если в данный момент с хранилищем работают читатели, то:      */
/*           - вывести на экран и записать в файл                        */
/*             информационное сообщение об этом;                         */
/*           - дождаться окончания работы всех читателей.                */
/*    3.6) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс получил доступ к хранилищу.               */
/*    3.7) Выждать 3 секунды.                                            */
/*    3.8) Сгенерировать случайное значение и записать его в хранилище.  */
/*    3.9) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс записал сообщение в хранилище             */
/*         и завершил работу.                                            */
/*    3.10) Разрешить доступ к хранилищу читателям.                      */
/*    3.11) Разрешить доступ к хранилищу писателям                       */
/*          (снять замок writeLock).                                     */
/*************************************************************************/
void writer(int& storage, int totalWriters, int& activeReaders,
               omp_lock_t& writeLock, bool& readLock)
{
#pragma omp parallel num_threads(totalWriters) // Создать параллельные
       {                                       //  потоки.
             bool flag;                       // Переменная используется для того, чтобы
                                               //  подавить вывод повторных сообщений
                                               //  на экран и в файл, если писатель
                                               //  ожидает, пока читатели завершат
                                               //  работу с хранилищем.

             int writerNumber = omp_get_thread_num();        // Определить номер
                                                            //  потока-писателя.
             while(true)                                    // Выполнять в бесконечном
             {                                              //  цикле.
                    flag = false;
                    Sleep(rand() * writerNumber % 15000 + 3000);
                                               // Выждать случайное время от 3 до 18 секунд
                                               //  (множитель writerNumber нужен для того,
                                               //  чтобы результат различался
                                               //  для разных потоков).
#pragma omp critical                                  // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Писатель %d обратился к хранилищу...\n", writerNumber);
                           fprintf(stream, ": Писатель %d обратился к хранилищу...\n",
                                   writerNumber);
                    }
                    if (!omp_test_lock(&writeLock))         // Если к хранилищу уже запросил
                    {                                       //  доступ другой писатель, то
#pragma omp critical                                               //  вывести информацию на экран
                           {                                 //  и в файл.
                                  printf("Другой писатель обратился к хранилищу раньше. ");
                                  printf("Писатель %d ожидает.\n", writerNumber);
                                  fprintf(stream,
 "Другой писатель обратился к хранилищу раньше. ");
                                  fprintf(stream, "Писатель %d ожидает.\n", writerNumber);
                           }
                           omp_set_lock(&writeLock);         // Заблокировать текущий поток.
                    } // if (!omp_test_lock(&writeLock))
                    readLock = true;                        // Запретить доступ к хранилищу
                                                            //  новым читателям.
                    while(activeReaders != 0)         // Дождаться окончания работы
                           {                          //  с хранилищем текущих читателей.
                                  if (!flag)          // Если информация ещё не выводилась,
                                  {                   //  то вывести её на экран и в файл.
#pragma omp critical
                                         {
                                        printf("Писатель %d ожидает, пока ", writerNumber);
                                        printf("активные читатели закончат работу с хранилищем.\n");
                                        fprintf(stream,
                                                   "Писатель %d ожидает, пока ", writerNumber);
                                        fprintf(stream,
                                          "активные читатели закончат работу с хранилищем.\n");
                                        }
                                  } //if (!flag)
                                  flag = true;        // Отметить факт вывода информации.
                                  Sleep(100);         // Выждать 0,1 секунды.
                           } // while(activeReaders != 0)
#pragma omp critical                                        // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Писатель %d получил доступ к хранилищу.\n", writerNumber);
                           fprintf(stream,
                                      ": Писатель %d получил доступ к хранилищу.\n", writerNumber);
                    }
                    Sleep(3000);                      // Выждать 3 секунды.
                    storage = rand() + writerNumber;  // Сгенерировать сообщение
                                                      //  и записать его в хранилище.
#pragma omp critical                                        // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Писатель %d записал в хранилище ", writerNumber);
                           printf("сообщение %d и закончил работу.\n", storage);
                           fprintf(stream,
                                      ": Писатель %d записал в хранилище ", writerNumber);
                           fprintf(stream,
                                      "сообщение %d и закончил работу.\n", storage);
                    }
                    readLock = false;          // Разрешить доступ к хранилищу читателям.
                    omp_unset_lock(&writeLock);       // Разрешить доступ к хранилищу писателям.
             } // while(true)
       } // #pragma omp parallel
}

/*************************************************************************/
/* Процедура reader, моделирующая действия читателей.                    */
/* Принимаемые параметры:                                                */
/*   storage - хранилище, из которого читатель получает сообщение;       */
/*   totalReaders - количество читателей;                                */
/*   activeReaders - количество читателей, работающих с хранилищем       */
/*     в настоящий момент;                                               */
/*   readLock - переменная для блокировки читателей.                     */
/* Глобальные переменные:                                                */
/*   stream - файловый поток.                                            */
/* Возвращаемый результат: нет                                           */
/* Изменяемые переменные: activeReaders.                                 */
/*                                                                       */
/* Алгоритм работы:                                                      */
/* 1) Создать параллельные потоки в количестве totalReaders.             */
/* 2) Определить номер threads текущего потока-читателя.                 */
/* 3) Выполнять в бесконечном цикле:                                     */
/*    3.1) Выждать случайное время (в диапазоне от 3 до 15 секунд).      */
/*    3.2) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс обратился к хранилищу.                    */
/*    3.3) Если доступ к хранилищу для читателей заблокирован, то:       */
/*           - вывести на экран и записать в файл                        */
/*             информационное сообщение об этом;                         */
/*           - дождаться снятия блокировки.                              */
/*    3.4) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс получил доступ к хранилищу.               */
/*    3.5) Увеличить значение переменной activeReaders на единицу.       */
/*    3.6) Выждать 3 секунды.                                            */
/*    3.7) Вывести на экран и записать в файл сообщение о том,           */
/*         что текущий процесс получил сообщение из хранилища            */
/*         и завершил работу.                                            */
/*    3.8) Уменьшить значение переменной activeReaders на единицу.       */
/*************************************************************************/
void reader(int& storage, int totalReaders, int& activeReaders,
                    bool& readLock)
{
#pragma omp parallel num_threads(totalReaders) // Создать параллельные
       {                                       //  потоки.
             bool flag;                        // Переменная используется для того, чтобы
                                               //  подавить вывод повторных сообщений
                                               //  на экран и в файл, если писатель
                                               //  ожидает, пока читатели завершат
                                               //  работу с хранилищем.

             int readerNumber = omp_get_thread_num(); // Определить номер
                                                      //  потока-читателя.
             while(true)                             // Выполнять в бесконечном
             {                                       //  цикле.
                    flag = false;
                    Sleep(rand() * readerNumber % 12000 + 3000);
                                               // Выждать случайное время от 3 до 15 секунд
                                               //  (множитель readerNumber нужен для того,
                                               //  чтобы результат различался
                                               //  для разных потоков).
#pragma omp critical                                  // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Читатель %d обратился к хранилищу...\n", readerNumber);
                           fprintf(stream,
                                     ": Читатель %d обратился к хранилищу...\n", readerNumber);
                    }
                    while(readLock == true)    // Дождаться доступа к хранилищу.
                           {
                                  if (!flag)   // Если информация ещё не выводилась,
                                  {
#pragma omp critical                                  //  то вывести её на экран и в файл.
                                        {
                                               printf("Доступ к хранилищу заблокирован. ");
                                               printf("Читатель %d ожидает.\n", readerNumber);
                                               fprintf(stream,
                                                          "Доступ к хранилищу заблокирован. ");
                                               fprintf(stream,
                                                          "Читатель %d ожидает.\n", readerNumber);
                                        }
                                  }
                                  flag = true; // Отметить факт вывода информации.
                                  Sleep(100);  // Выждать 0,1 секунды.
                           }
#pragma omp critical                                  // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Читатель %d получил доступ к хранилищу.\n", readerNumber);
                           fprintf(stream,
                                  ": Читатель %d получил доступ к хранилищу.\n", readerNumber);
                    }
#pragma omp atomic
                    activeReaders++;           // Увеличить количество активных читателей.
                    Sleep(3000);               // Выждать 3 секунды.
#pragma omp critical                                  // Вывести информацию на экран и в файл.
                    {
                           printTimeStamp();
                           printf(": Читатель %d прочитал из хранилища ", readerNumber);
                           printf("сообщение %d и закончил работу.\n", storage);
                           fprintf(stream,
                                     ": Читатель %d прочитал из хранилища ", readerNumber);
                           fprintf(stream,
                                     "сообщение %d и закончил работу.\n", storage);
                    }
#pragma omp atomic
                    activeReaders--;           // Уменьшить количество активных читателей.
             } // while(true)
       } // #pragma omp parallel
}

/*************************************************************************/
/* Главная процедура main.                                               */
/* Принимаемые параметры: нет                                            */
/* Глобальные переменные: нет                                            */
/* Возвращаемый результат: нет                                           */
/*                                                                       */
/* Выполняемые действия:                                                 */
/* 1) Определить файл для вывода информации.                             */
/* 2) Инициализировать замок для взаимоблокировки писателей.             */
/* 3) Включить обработку вложенных директив OpenMP.                      */
/* 4) Запросить у пользователя следующие исходные данные:                */
/*    - количество потоков-писателей totalWriters;                       */
/*    - количество потоков-читателей totalReaders.                       */
/* 5) Создать два параллельных потока и в одном из них вызвать           */
/*    процедуру моделирования писателей, а в другом - процедуру          */
/*    моделирования читателей.                                           */
/*************************************************************************/
int main()
{
       setlocale (LC_ALL,"Russian");
       srand (time(NULL));

       int storage = 0;                        // Хранилище.
       int totalWriters = 0,                          // Количество писателей.
             totalReaders = 0;                 // Количество читателей.
       int activeReaders = 0;                  // Количество читателей, работающих с хранилищем
                                               //  в настоящий момент.
       omp_lock_t writeLock;                          // Замок для блокировки писателей.
       bool readLock = false;                  // Переменная для блокировки читателей:
                                               //  true - чтение запрещено;
                                               //  false - чтение разрешено.

       fopen_s(&stream, "log.txt", "w");       // Определить файл для вывода информации.

       omp_init_lock(&writeLock);               // Инициализировать замок.
       omp_set_nested(true);                          // Включить обработку вложенных директив OpenMP.

       /* Запросить у пользователя исходные данные. */
       printf ("Лабораторная работа N 6.\n");
       printf ("Программная реализация задачи \"Писатели-читатели\".\n\n");
       printf ("Введите количество писателей: ");
       cin >> totalWriters;
       printf ("Введите количество читателей: ");
       cin >> totalReaders;
       printf ("\nМоделирование началось. Для завершения работы нажмите Ctrl+C.\n");

#pragma omp parallel sections                  // Создать два параллельных потока.
       {
#pragma omp section                            // Вызвать процедуру моделирования
             {                                 //  писателей в первом потоке.
                    writer(storage, totalWriters, activeReaders,
                              writeLock, readLock);
             }
#pragma omp section                            // Вызвать процедуру моделирования
             {                                 //  читателей во втором потоке.
                    reader(storage, totalReaders, activeReaders,
                              readLock);
              }
       } // #pragma omp parallel sections

}
