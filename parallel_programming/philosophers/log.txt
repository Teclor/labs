#include <iostream>
#include <fstream>
#include <omp.h>
#include <string>
#include <windows.h>
#include <time.h>

using namespace std;

ofstream stream("philosophers.txt");

const int philCount = 5;
bool forks[philCount];

string getTime() {
    #pragma omp parallel 
    {
        SYSTEMTIME timeStamp;
        GetLocalTime(&timeStamp);
        return to_string(timeStamp.wHour) + ":" + to_string(timeStamp.wMinute) + ":" + to_string(timeStamp.wSecond) + ":" + to_string(timeStamp.wMilliseconds);
    }
}


bool checkForks(int forkLeft) 
{
    #pragma omp parallel shared(forks)
        {
    #pragma omp critical 
            {
                return forks[forkLeft] && forks[forkLeft + 1];
            }
        }
}
void changeForksAvailability(int forkLeft, bool newValue) {
    #pragma omp parallel shared(forks)
        {
    #pragma omp critical 
            {
                forks[forkLeft] = newValue;
                forks[forkLeft + 1] = newValue;
            }
        }
}
void writeAndDump(string txt) {
    #pragma omp parallel
        {
    #pragma omp critical 
            {
                cout << txt;
                stream << txt;
            }
        }
}
class Philosopher {
    int pNum;
public:
    Philosopher() {
       pNum = 0;
    }
    Philosopher(int num) {
        pNum = num;
        for (int i = 0; i < philCount; i++)
        {
            forks[i] = true; //вилка свободна
        }
    }
    void eat() {
            int forkLeft = pNum - 1;
            int forkRight = forkLeft < philCount ? forkLeft + 1 : 0;
            if (checkForks(forkLeft)) {
                    changeForksAvailability(forkLeft, false);
                    string time = getTime();
                    string strOut = "Философ " + to_string(pNum) + " трапезничает c " + time + " вилками " + to_string(forkLeft) + " и " + to_string(forkRight) +"\n";
                    writeAndDump(strOut);
                    int timeWait = rand() * pNum % 9000 + 1000;
                    Sleep(timeWait);
                    time = getTime();
                    strOut = "Философ " + to_string(pNum) + " закончил трапезу в " + time + " спустя " + to_string(timeWait / 1000) + "с" + "\n";
                    writeAndDump(strOut);
                    changeForksAvailability(forkLeft, true);
                }
            else { 
                    string strOut = "Философ " + to_string(pNum) + " в раздумьях" + "\n";
                    writeAndDump(strOut);
            }

        }
};
int main(void) {
    setlocale(LC_ALL, "Russian");
    Philosopher ph[philCount+1];
    for (int i = 1; i <= philCount; i++) {
        ph[i] = Philosopher(i);
    }
    time_t timeStamp;
    time_t timeStampTmp;
    time(&timeStamp);
    time(&timeStampTmp);
    while ((timeStampTmp - timeStamp) < 1)
    {
        time(&timeStampTmp);
        cout << timeStampTmp - timeStamp << endl;
#pragma omp parallel num_threads(philCount)
        {
            int num = omp_get_thread_num();
            ph[num+1].eat();
        }
        cout << "Конец очередной итерации\n";
        stream << "-----------------------\nКонец очередной итерации\n-----------------------\n";
    }
    stream.close();
    return 0;
}